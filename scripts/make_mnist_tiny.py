#!/usr/bin/env python3
"""Generate a tiny deterministic MNIST fixture for tests.

This script creates a small subset of MNIST images for unit tests,
avoiding the need to download the full dataset during CI.

Usage:
    python scripts/make_mnist_tiny.py

Output:
    tests/assets/mnist_tiny/
        train_images.npy   (uint8, shape [K, 28, 28])
        train_labels.npy   (int64, shape [K])
        test_images.npy    (uint8, shape [K, 28, 28])
        test_labels.npy    (int64, shape [K])
        README.md          (metadata about how it was created)
"""

from __future__ import annotations

import tempfile
from pathlib import Path

import numpy as np

try:
    from torchvision import datasets
except ImportError as err:
    print("Error: torchvision is required. Install with: pip install torchvision")
    raise SystemExit(1) from err


def main() -> None:
    """Generate the tiny MNIST fixture."""
    # Configuration
    K = 64  # Number of samples per split
    output_dir = Path(__file__).parent.parent / "tests" / "assets" / "mnist_tiny"
    output_dir.mkdir(parents=True, exist_ok=True)

    print(f"Generating tiny MNIST fixture with K={K} samples per split...")
    print(f"Output directory: {output_dir}")

    # Download MNIST to a temp directory
    with tempfile.TemporaryDirectory() as tmpdir:
        print("Downloading MNIST to temporary directory...")

        # Load train and test sets (raw, no transforms)
        train_ds = datasets.MNIST(root=tmpdir, train=True, download=True)
        test_ds = datasets.MNIST(root=tmpdir, train=False, download=True)

        # Extract first K samples deterministically
        train_images = []
        train_labels = []
        for i in range(K):
            img, label = train_ds[i]
            # Convert PIL Image to numpy array
            train_images.append(np.array(img, dtype=np.uint8))
            train_labels.append(label)

        test_images = []
        test_labels = []
        for i in range(K):
            img, label = test_ds[i]
            test_images.append(np.array(img, dtype=np.uint8))
            test_labels.append(label)

        # Stack into arrays
        train_images_arr = np.stack(train_images)
        train_labels_arr = np.array(train_labels, dtype=np.int64)
        test_images_arr = np.stack(test_images)
        test_labels_arr = np.array(test_labels, dtype=np.int64)

        print(f"Train images shape: {train_images_arr.shape}")
        print(f"Train labels shape: {train_labels_arr.shape}")
        print(f"Test images shape: {test_images_arr.shape}")
        print(f"Test labels shape: {test_labels_arr.shape}")

        # Save to output directory
        np.save(output_dir / "train_images.npy", train_images_arr)
        np.save(output_dir / "train_labels.npy", train_labels_arr)
        np.save(output_dir / "test_images.npy", test_images_arr)
        np.save(output_dir / "test_labels.npy", test_labels_arr)

        # Write README
        readme_content = f"""# MNIST Tiny Fixture

This directory contains a deterministic subset of MNIST for unit tests.

## Contents

- `train_images.npy`: Training images (uint8, shape [{K}, 28, 28])
- `train_labels.npy`: Training labels (int64, shape [{K}])
- `test_images.npy`: Test images (uint8, shape [{K}, 28, 28])
- `test_labels.npy`: Test labels (int64, shape [{K}])

## Generation

Generated by `scripts/make_mnist_tiny.py` with:
- K = {K} samples per split
- Indices: first {K} samples from each split (deterministic)
- Source: torchvision.datasets.MNIST

## Label Distribution

Train labels: {dict(zip(*np.unique(train_labels_arr, return_counts=True), strict=True))}
Test labels: {dict(zip(*np.unique(test_labels_arr, return_counts=True), strict=True))}

## Usage

```python
from tasks.mnist import load_mnist_tiny

train_ds, test_ds = load_mnist_tiny(Path("tests/assets/mnist_tiny"))
```
"""
        (output_dir / "README.md").write_text(readme_content)

        print("\nFixture created successfully!")
        print(f"Files saved to: {output_dir}")

        # Print label distribution
        train_dist = dict(zip(*np.unique(train_labels_arr, return_counts=True), strict=True))
        test_dist = dict(zip(*np.unique(test_labels_arr, return_counts=True), strict=True))
        print(f"\nTrain label distribution: {train_dist}")
        print(f"Test label distribution: {test_dist}")


if __name__ == "__main__":
    main()
